<3.5.1 형식 검사>
람다 표현식을 처음 설명할 떄 람다로 함수형 인터페이스의 인스턴스를 만들 수 있다고 언급했다
그러나 람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지 정보가 포함되지 않다
따라서 람다 표현식을 이해하려면 람다의 실제 형식을 파악해야 한다

람다가 사용하는 컨텍스트(context)를 이용해서 람다의 형식(type)을 추론할 수 있다
어떤 컨텍스트(람다가 전달할 메서드 파라미터, 람다가 할당되는 변수 등)에서 기대되는 람다 표현식의 형식을 대상 형식(target type)이라고 부른다

예) 람다 표현식
List<Apple> heavierThan150g = filter(inventory, (Apple apple) -> apple.getWeight() > 150);
이 예제는 다음과 같은 순서로 형식 확인 과정이 진행된다
1. filter() 메서드의 선언 확인
2. filter() 메서드는 두 번째 파라미터로 Predicate<Apple> 형식(대상 형식)을 기대한다
3. Predicate<Apple>은 test() 라는 추상 메서드를 정의하는 함수형 인터페이스다
4. test() 메서드는 Apple 를 받아 boolean 을 반환하는 함수 디스크립터를 묘사한다
5. filter() 메서드로 전달될 인수는 이와 같은 요구사항을 만족해야 한다

즉, filter(inventory, (Apple apple) -> apple.getWeight() > 150); 는 람다가 사용된 컨텍스트가 무엇인지 확인하기 위해 filter 의 정의를 확인한다
filter(List<Apple> inventory, Predicate<Apple> p); 확인된 filter 의 정의에서 대상 형식은 Predicate<Apple> 임을 알게된다
이때, 타입 파라미터 T 는 Apple 로 대치된다
그 다음 대상 형식인 Predicate<Apple> 인터페이스의 추상메서드는 무엇인지 찾는다
추상 메서드 boolean test(Apple apple) 를 찾은 후, Apple 를 인수로 받아 boolean 을 반환하는 test() 메서드 임을 확인한다
함수 디스크립터는 Apple -> boolean 이므로 람다의 시그니처와 일치한다
람다도 Apple 을 인수로 받아 boolean 을 반환하므로 코드 형식 검사가 성공적으로 완료된다

* 만약 람다 표현식이 예외를 던질 수 있다면 추상 메서드도 같은 예외를 던질 수 있도록 throws 로 선언해야 한다
---
<3.5.2 같은 람다, 다른 함수형 인터페이스>
대상 형식(target typing)이라는 특징 때문에 같은 람다 표현식이더라도 호환되는 추상 메서드를 가진 다른 함수형 인터페이스로 사용될 수 있다
예) 인수를 받지 않고 제네릭 T를 반환하는 함수를 정의하는 Callable, PrivilegedAction 인터페이스 예제
Callable<Integer> c = () -> 42;
PrivilegedAction<Integer> p = () -> 42;
위 예제에서 첫 번쨰 할당문의 대상 형식(target typing)은 Callable<Integer> 이고 두 번째 할당문의 대상형식은 PrivilegedAction<Integer>이다
그리고 둘다 람다 표현식은 () -> 42; 이다

하나의 람다 표현식은 다양한 함수형 인터페이스에 사용할 수 있다
---
<다이아몬드 연산자>
다이아몬드 연산자<> 로 컨텍스트에 따른 제네릭 형식을 추론할 수 있다
클래스 인스턴스 표현식을 두 개 이상의 다양한 컨텍스트에 사용할 수 있다
이때 인스턴스 표현식의 형식 인수는 컨텍스트에 의해 추론된다
List<String> listOfStrings = new ArrayList<>(); // 앞의 클래스 인스턴스 표현식이 String 타입이므로 뒤의 인스턴스 표현식의 형식 인수는 컨텍스트에 의해 String 으로 추론된다
List<Integer> listOfIntegers = new ArrayList<>(); // 앞의 클래스 인스턴스 표현식이 Integer 타입이므로 뒤의 인스턴스 표현식의 형식 인수는 컨텍스트에 의해 Integer 으로 추론된다
---
<특별한 void 호환 규칙>
람다의 바디에 어떤 값을 반환하는 일반 표현식(expression)이 있더라도
만약 그 람다가 void 를 반환하도록 기대하는 함수형 인터페이스(void 를 반환하는 함수 디스크립터)컨텍스트에서 사용된다면
해당 람다는 유효하다
즉, void 를 반환하는 함수 디스크립터와 호환된다(단, 파라미터 리스트가 호환되어야함)

예) 아래 두 행은 List 의 add() 메서드는 boolean 을 반환하지만 유효한 코드
Predicate<String> p = s -> list.add(s); // Predicate 는 boolean 반환값을 가지므로 타입이 일치한다
Consumer<String> b = s -> list.add(s);
/*
Consumer 는 void 반환값을 가진다
Consumer<String>의 함수 디스크립터는 (String) -> void 이다(void 를 반환해야한다는 의미)
그러나 list.add(s) 는 boolean 값을 반환하는 메서드이다
하지만 여기서 void 호환 규칙 때문에 list.add(s) 의 boolean 반환값이 Consumer 컨텍스트에서 무시된다
그러므로 유효한 코드가 된다
*/

같은 함수형 디스크립터를 가진 두 함수형 인터페이스를 갖는 메소드를 오버로딩 할 경우, 람다 표현식을 명시적으로 캐스팅하면
누구를 호출할 것인지 명확해진다
예) 같은 함수형 디스크립터를 가진 함수형 인터페이스
// execute(() -> {}) 라는 람다 표현식이 있는 경우 같은 함수 디스크립터가 같으므로 누구를 가르키는지 명확하지 않는다
public void execute(Runnable runnable) {
    runnable.run();
}
public void execute(Action<T> action) {
    action.run();
}
@FunctionalInterface
interface Action {
    void act();
}
이때 execute((Action) () -> {}); 처럼 캐스트를 하면 누구를 호출할 것인지 명확해진다
---
<3.5.3 형식 추론>
자바 컴파일러는 람다 표현식이 사용된 컨텍스트(대상 형식)을 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다
즉, 대상 형식을 이용해서 함수 디스크립터를 알 수 있으므로, 컴파일러는 람다의 시그니처도 추론할 수 있다
결과적으로 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 람다 문법에서 람다 표현식의 파라미터 타입을 생략할 수 있다
예) 파라미터 apple 의 형식을 명시적으로 지정하지 않은 경우
List<Apple> greenApples = filter(inventory, apple -> GREEN.equals(apple.getColor()));

예) 형식 추론이 사용된 람다 표현식 차이
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()); // 형식 추론 x
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight()); // 형식 추론 O

상황에 따라 명시적으로 형식을 포함하는 것이 좋을 때도 있고 형식을 배제하는 것이 가독성을 향상시킬 때도 있다
어떤 방법이 좋은지 정해진 규칙은 없다
---
<3.5.4 지역 변수 사용>
람다 표현식은 익명 함수가 하는 것처럼 자유 변수(free variable, 파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있다
이와 같은 동작을 람다 캡처링(capturing lambda)이라고 부른다
예) 자유변수를 캡처하는 람다 표현식
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);

람다는 인스턴스 변수와 정적 변수를 자유롭게 캡처(자신의 바디에서 참조)할 수 있다
하지만 이 경우 지역 변수는 명시적으로 final 로 선언되거나 실질적으로 final 로 선언된 변수와 똑같이 사용되어야 한다
즉, 람다 표현식은 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있다(자신의 바디에서 참조할 수 있다)
예) 자유 변수에 값을 두번 할당하기 때문에 컴파일 할 수 없는 코드
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 31337; // 컴파일 에러 발생 - final 변수 처럼 값이 변경된선 안된다
---
내부적으로 인스턴스 변수와 지역 변수는 태생부터 다르다
인스턴스 변수는 힙(heap)에 저장되는 반면
지역 변수는 스택(stack)에 위치한다
람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면
변수를 할당한 스레드가 사라지기 떄문에 변수 할당이 해제된다
그런데 변수 할당이 해제된 상태에도 람다를 실행하는 스레드는 해당 변수에 접근하려 할 수 있다
따라서 자바 구현에서는 원래 변수에 접근을 허용하는게 아닌, 자유 지역 변수의 '복사본'을 제공한다
그러므로 '복사본'의 값이 바뀌지 않아야 하므로 지역 변수는 한 번만 값을 할당해야 한다는 제약이 생긴다

또한 지역 변수의 제약 떄문에 외부 변수를 변화시키는 일반적인 명령형 프로그래밍 패턴(병렬화를 방해하는 요소)에 제동을 걸 수 있다
---
<클로져, closure>
클로저란, 함수의 지역변수가 아닌 변수를 자유롭게 참조할 수 있는 '함수의 인스턴스'를 가리킨다
예를 들어 클로저를 다른 함수의 인수로 전달할 수 있다. 클로저는 클로저 외부에 정의된 변수의 값에 접근하고 값을 바꿀 수 있다
자바8의 람다와 익명 클래스는 클로저와 비슷한 동작을 수행한다
람다와 익명 클래스 모두 메서드의 인수로 전달될 수 있으며 자신의 외부 영역의 변수에 접근할 수 있다
그러나 람다와 익명 클래스는 람다가 정의된 메서드의 지역 변수의 값을 바꿀 수 없다(람다가 정의된 메서드의 지역 변수값은 final 변수여야 하기 때문)
람다는 변수가 아닌 값에 국한되어, 어떤 동작을 수행한다는 사실이 명확해진다
지역 변수값은 스택에 존재하므로 자신을 정의한 스레드와 생존을 같이 해야 하기 떄문에 지역 변수는 final 이어야 한다
가변 지역 변수를 새로운 스레드에서 캡처할 수 있다면, 안전하지 않은 동작을 수행할 가능성이 생긴다
(인스턴스 변수는 스레드가 공유하는 힙에 존재하므로 특별한 제약이 없다)