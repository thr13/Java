<4.3 스트림과 컬렉션>
컬렉션과 스트림 모두 연속된(sequenced) 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다
* 여기서 '연속된' 이라는 것은 순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근하는 것을 의미한다

컬렉션과 스트림의 차이로는 '데이터를 언제 계산하느냐' 가 큰차이다
컬렉션은 현재 자료구조를 포함하는 모든 값을 메모리에 저장하는 자료구조다
즉, 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 한다
(컬렉션에 요소를 추가하거나 컬력센의 요소를 삭제하는 등 이런 연산을 수행할 떄마다
컬렉션의 모든 요소를 메모리에 저장해야 하며 컬렉션에 추가하려는 요소는 미리 계사된어야 한다)

반면 스트림은 이론적으로 요청할 떄만 요소를 계산하는 고정된 자료구조 이다(스트림에 요소를 추가하거나, 요소를 제거할 수 없다)
사용자가 요청하는 값만 스트림에서 추출하는게 핵심이다
스트림은 생산자(producer)와 소비자(consumer)관계를 형성한다 또한 스트림은 게으르게 만들어진 컬렉션과 같다
사용자가 데이터를 요청할 때만 값을 계산하기 때문이다
반면 컬렉션은 적극적으로 생성된다(생상자 중심, supplier-driven)
대표적인 예로 소수를 만드는 프로그램이 있다고 하면 컬렉션은 끝이 없는 모든 소수를 포함하려 할 것이므로 무한 루프를 돌면서 새로운 소수를 계산하고 추가하는 것을 반복할 것이다
결국 소비자는 영원히 결과를 볼 수 없다

'적극적 생성'이란 모든 값을 계산할 때까지 기다린다는 의미이다
'게으른 생성'이란 필요할 때만 값을 계산한다는 의미이다
---
<4.3.1 한 번의 탐색>
반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다
즉, 탐색된 스트림의 요소는 소비된다
반복자와 마찬가지로 한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다
(만일 데이터가 소스가 I/O 채널이라면 소스를 반복 사용할 수 없으므로 새로운 스트림을 만들 수 없다)
---
<스트림과 컬렉션의 철학적 접근>
스트림을 시간적으로 흩어진 값의 집합으로 간주할 수 있다
반면 컬렉션은 특정 시간에 모든 것이 존재하는 공간(컴퓨터 메모리)에 흩어진 값으로 비유할 수 있다
그러므로 (컬렉션의) for-each 루프 내에서 반복자를 이용해서 공간에 흩어진 요소에 접근할 수 있다
---
<4.3.2 외부 반복과 내부 반복>
컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다(예: for-each 문 사용)
이것을 외부 반복(external iteration)이라고 한다
반면 스트림 라이브러리는 내부 반복(internal iteration)을 사용한다(반복을 알아서 처리하고 결과 스트림 값을 어딘가에 저장해줌)
함수에 어떤 작업을 수행할지만 지정하면 모든 것이 자동으로 처리된다

컬렉션은 '외부적으로' 반복 즉, 명시적으로 컬렉션 항목들을 하나씩 가져와서 처리한다
내부 반복자는 작업을 투명하게 병렬로 처리하거나 더 최적화된 순서로 처리할 수 있다

스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다
반면에 for-each 를 이용한는 외부 반복은 병렬성을 '스스로 관리'해야 한다
(병렬성을 스스로 관리한다는 것은 병렬성을 포기하든지, 아니면 synchronized 로 시작하는 복잡한 코드를 의미한다)

스트림은 내부 반복을 사용하므로 반복 과정을 개발자가 신경 쓰지 않아도 된다
(단, filter 나 map 같이 반복을 숨겨주는 연산 리스트가 미리 정의되어 있어야 한다)
반복을 숨겨주는 대부분의 연산은 람다 표현식을 인수로 받을 수 있으므로 동작 파라미터화를 활용할 수 있다