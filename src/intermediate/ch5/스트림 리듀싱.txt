<5.5 리듀싱>
리듀스(reduce) 연산을 이용해서 '메뉴에서 칼로리가 가장 높은 요리는?' 와 같은 스트림 요소를 조합한 복잡한 질의는
특정 타입의 결과가 나올 때까지 스트림의 모든 요소를 반복적으로 처리해야 한다
이런 질의를 리듀싱 연산이라고 한다(모든 스트림 요소를 처리해서 값으로 도출)
함수형 프로그래밍 언어 용어로는 이 과정이 마치 종이를 작은 조각이 될 때까지 반복해서 접는 것과 비슷하다는 의미로 폴드(fold)라고 부른다

<5.5.1 요소의 합>
예) 리스트의 숫자 요소를 더하는 for-each 루프 코드
int sum = 0;
for (int x: numbers) {
    sum += x;
}

numbers 의 각 요소는 결과(sum) 에 반복적으로 더해진다 리스트에서 하나의 숫자가 남을 때까지 reduce 과정을 반복한다
위 코드는 파라미터를 2개 사용했다 하나는 sum 변수의 초기값 0, 다른 하나는 리스트의 모든 요소를 조립하는 연산(+)

reduce() 이용하면 애플리케이션의 반복된 패턴을 추상화할 수 있다
예) reduce() 를 이용해서 스트림의 모든 요소 더하기
int sum = numbers.stream()
                .reduce(0, (a, b) -> a + b);

위 코드에서 reduce() 메소드는 2 개의 인수를 가진다
하나는 초기값 0 이고 다른 하나는 두 요소를 조합해서 새로운 값을 만드는 BinaryOperator<T> (람다 표현식 (a, b) -> a + b 을 의미)

reduce() 로 다른 람다 즉, (a, b) -> a * b 를 넘겨주면 모든 요소에 곱셈을 적용할 수 있다
int product = numbers.stream()
                .reduce(1, (a,b) -> a * b);
위 스트림에서 reduce() 연산은 스트림이 하나의 값으로 줄어들때까지 람다는 각 요소를 반복해서 조합한다

람다의 첫 번째 파라미터(a)에는 초기값(0)을 사용하고 스트림에서 요소를 소비해 두 번째 파라미터(b)로 사용한다
이 결과는 새로운 누적값(accumulated value)가 된다 그 후 누적값으로 람다를 다시 호출하여 새로운 요소를 소비한다
이를 반복해서 누적값과 스트림의 마지막 요소를 호출하면 최종값을 구할 수 있다

메서드 참조를 이용해서 위 예제 코드를 간결하게 만들 수 있다
자바8 버전에서는 Integer 클래스에 두 숫자를 더하는 정적 sum() 메서드가 제공된다 따라서 직접 람다 코드를 구현할 필요가 없다
int sum = numbers.stream().reduce(0, Integer::sum);
---
<초기값이 없는 reduce>
초기값을 받지 않도록 오버로드된 reduce 도 존재한다
그러나 이 reduce 는 Optional 객체를 반환한다
Optional<Integer> sum = numbers
                .stream()
                .reduce((a,b) -> (a + b));
스트림에 아무 요소가 없는 상황이라면, 초기값을 없으므로 reduce 의 합계를 반환할 수 없다
그러므로 합게가 없을 가리킬 수 있도록 Optional 객체로 감싼 결과를 반환한다

<5.5.2 최대값과 최소값>
최대값과 최소값을 찾을 대도 reduce() 를 활용할 수 있다
reduce() 는 두 인수를 받는다
1. 초기값
2. 스트림의 두 요소를 합쳐서 하나의 값으로 만드는 데 사용할 람다

최대값/최소값을 반환하는 람다만 있다면 최대값/최소값을 구할 수 있다
즉, reduce() 연산은 새로운 값을 이용해서 스트림의 모든 요소를 소비할 때까지 람다를 반복 수행하면서 최대값을 생산한다
Optional<Integer> max = numbers.stream().reduce(Integer::max);
Optional<Integer> min = numbers.stream().reduce(Integer::min);

Integer::min 대신 람다 표현식 (x, y) -> x < y ? x : y 를 사용해도 무방하지만 메서드 참조 표현이 가독성이 더 좋다
---
<reduce() 메서드의 장점과 병렬화>
기존의 단계적 반복으로 합계를 구하는 것과, reduce() 를 이용해서 합계를 구하는 방식은 차이가 있다
reduce() 를 이용하면 내부 반복이 추상화되면서 내부 구현에서 병렬로 reduce()를 실행할 수 있다
반복적인 합계는 변수 sum 을 공유해야 하므로 병렬화하기 어렵다
강제적으로 동기화시키더라도 결국 병렬화로 얻어야 할 이득이 스레드 간의 소모적인 경쟁 때문에 상쇄되어 버린다

int sum = numbers.parallelStream().reduce(0, Integer::sum);
이 코드는 병렬로 실행하지만 대가를 지불해야 한다
즉, reduce() 에 넘겨준 람다의 상태(인스턴스 변수)가 바뀌지 말아야 하며, 연산이 어떤 순서로 실행되더라도 결과가 바뀌지 않는 구조여야 한다
---
<스트림 연산: 상태 없음과 상태 있음>
map(), filter() 등은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림을 보낸다
따라서 사용자가 제공한 람다나 메서드 참조가 내부적인 가변 상태를 갖지 않는다는 가정하에
이들은 상태가 없는, 내부 상태를 갖지 않는 연산(stateless operation)이다

그러나 reduce(), sum(), max() 같은 연산은 결과를 누적할 내부 상태가 필요하다
(예제에서는 int 또는 double 을 내부 상태로 이용함)
스트림에서 처리하는 요소 수와 관계없이 내부 상태의 크기는 한정(bounded)되어 있다

반면에 sorted() 나 distinct() 같은 연산은 filter() 나 map() 처럼 스트림을 입력으로 받아 다른 스트림을 출력하는 것처럼 보일 수 있다
그러나 filter(), map() 과 달리 sorted(), distinct() 는 스트림의 요소를 정렬하거나 중복을 제거하려면 과거의 이력을 알고 있어야 한다
예를 들어 어떤 요소를 출력 스트림으로 추가하려면 모든 요소가 버퍼에 추가되어 있어야 한다
연산을 수행하는데 필요한 저장소 크기는 정해져 있지 않다
따라서 데이터 스트림의 크기가 크거나 무한하다면 문제가 발생할 수 있다
이런 연산을 내부 상태를 갖는 연산(stateful operation)이라고 한다