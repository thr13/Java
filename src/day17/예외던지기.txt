메소드 내부에서 예외가 발생했을때 try-catch 블록으로 예외를 처리하는 것이 기본이다
그런데 이 예외를 메소드를 호출한 곳으로 떠넘길 수 있다 이 경우 사용되는 키워드가 throws 인데 throws 는 메소드 선언부 끝에 작성되며 쉼표(,) 로 구분해서 넘길 예외 클래스를 여러개를 나열 할 수 있다

리턴타입 메소드명(매개변수, ... ) throws 예외클래스1, 예외클래스2, ... {
    // 메서드 내용
}

throws 키워드가 붙어 있는 메소드는 해당 예외를 처리하지 않고 넘기기 때문에
반드시 이 메소드를 호출하는 곳(상위 호출자)에서 예외를 받아(catch)서 예외를 처리해야한다

나열할 예외클래스가 많은 경우 throws Exception 또는 throws Throwable 만으로 간단히 떠넘길 수 있다
main() 메소드에서 throws 키워드를 사용해서 예외를 던질 경우 최종적으로 JVM 이 예외를 처리하게 된다 (내용을 콘솔에 출력)

throws 를 사용하는 경우:
메서드 내부에서는 어떻게 예외를 처리해야 할지 명확하지 않거나, 예외 처리 방식이 호출하는 쪽의 상황에 따라 달라져야 할 때,
Checked Exception (Exception 클래스를 상속받는 예외 클래스) 는 반드시 예외처리를 해야하는데 메서드 선언부에 throws() 를 명시해야 컴파일 에러가 발생한다

throws 의 단점:
예외처리 책임전가(호출자 부담 증가) - 내부에서 발생할 수 있는 예외를 직접 처리하지 않고 호출한 쪽으로 책임을 넘기게 되는데 이 경우 try-catch 블록으로 예외를 처리하거나 throws 를 사용해 상위 호출자에게 책임을 연쇄적을 넘겨야 하는 부담을 증가시킨다
예외처리 누락가능성 - Unchecked Exception (RuntimeException 클래스를 상속받는 예외 클래스)의 경우 throws 선언이 필수가 아니므로 호출자가 예외 발생 가능성을 간과하고 처리를 누락할 수 있다
API 변경의 어려움 - 만약 메서드 구현이 변경되어 새로운 Checked Exception 이 발생할 가능성이 생길 경우 해당 예외를 throws 선언부에 추가해야 한다 또한 메서드를 호출한 쪽의 코드에 영향을 미쳐 새로운 예외를 처리하거나 다시 던지도록 수정 해야한다 따라서 API 의 유연성을 저해하고 유지보수 비용을 증가시킨다
과도한 예외 위임으로 인한 코드 복잡성 증가 - 메서드 내부에서 처리할 수 있는 간단한 예외까지 모두 throws 로 위임하면, 호출하는 쪽의 try-catch 블록이 불필요하게 많아지거나 중첩되어 코드의 가독성을 떨어뜨리고 복잡성을 증가된다
불필요한 선언 - Unchecked Exception 에서는 프로그래밍 오류로 인해 발생하는 경우가 많으므로, 예외 처리보다는 코드 수정으로 해결하는 것이 더 적절하다