리소스(resource): 데이터를 제공하는 객체를 의미

리소스를 사용하기 위해서는 열어야(open) 하며, 사용이 끝난 뒤에는 닫아야(close) 한다
예를 들어 파일 내용을 읽기 위해서 파일을 열어야 하며, 다 읽고 난 후에는 파일을 닫아야 다른 프로그램에서 사용할 수 있다

리소스를 사용하다가 예외가 발생될 경우 안전하게 닫는 것이 중요하다 왜냐하면 닫지 않을 경우 리소스가 불안정한 상태로 남아있기 때문이다
자바에서 가비지컬렉터가 더 이상 참조되지 않는 객체들을 자동으로 찾아내서 메모리를 해제하는 역할을 수행하지 가비지컬렉터는 "메모리" 자원만 관리할 뿐이지
"시스템" 자원은 관리하지 않는다 ("시스템" 자원의 종류: 파일스트림, 데이터베이스 연결, 네트워크 소켓, 운영체제가 관리하는 외부 시스템 리소스 등)

시스템 자원은 운영체제 수준에서 관리되며, 개수가 제한적이므로 만약 이러한 리소스를 사용한 후 명시적으로 닫지 않으면, 프로그램이 종료될 때까지 혹은 시스템의 제한 개수에 도달할 때까지 계속 점유하고 있게 된다
또한, 열린 리소스는 시스템 자원을 계속 소비하므로 프로그램의 성능 저하를 유발할 수 있다 이는 곧 시스템 부담으로 연결되어 문제가 발생한다
그리고 데이터를 완전히 디스크에 쓰기 전에 스트림을 닫아야 데이터가 손실되지 않고 안전하게 저장되므로 데이터 무결성 관련해서 문제도 있다
그러므로 리소스를 닫는 것은 명시적으로 닫는게 좋다

try-with-resources
: try() { 내용 } 블록을 실행하기 전, try 문 에 괄호로 리소스를 여는 코드를 작성하면, try 블록 종료 후에 자동으로 리소스의 .close() 메소드가 호출된다
이를 사용하기 위해서는 해당 리소스가 java.lang.AutoCloseable 인터페이스를 구현해서 인터페이스의 close() 메서드를 오버라이드 해야한다
여러개의 리소스를 사용하는 경우 try() 괄호안에 세미콜론으로 구분해서 리소스를 여는 코드를 작성할 수 있다
JAVA 8 이전 버전은 try() 괄호안에서 리소스 변수를 반드시 선언해야했지만 JAVA 9 이후 버전부터는 외부에서 선언된 리소스 변수를 사용할 수 있다

try-with-resources 의 단점
: .close() 로 닫힌 리소스 객체는 더 이상 시스템 자원을 점유하지 않지만, 메모리에서는 여전히 존재할 수 있다 이것은 가비지 컬렉터에 의해 회수될 때까지 남아있다
try 블록이 끝나면 자동으로 close() 메서드가 호출되는데 이 close() 메서드 자체가 실패할 경우 문제가 발생한다
대표적인 예시로 파일을 닫는 과정에서 디스크에 오류가 발생하거나, 네트워크 연결을 끊는 과정에서 통신 문제가 발생할 수 있다 또한, 네트워크를 지속적으로 연결되는데 close() 메서드가 호출되서 연결이 끊길수도 있다

.close() 메서드에서 발생하는 예외는 try 블록에서 발생한 원래 예외에 suppressed exception (억제된 예외) 형태로 예외에 연결된다 이것은 getCause() 메서드로 접근할 수 있다
try() 괄호 내부에서 다중 리소스 선언시 선언된 순서의 역순으로 .close() 메서드가 호출된다 이 경우 외부 리소스를 사용하는 내부 리소스가 있다면 내부 리소스가 먼저 닫히고 외부 리소스가 나중에 닫히는 순서가 보장된다

